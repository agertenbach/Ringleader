# Ringleader
Extends the NET Core default HttpClientFactory to support managing and applying contextually appropriate primary handlers (i.e. unique certificates for different endpoints) while retaining the benefits of handler pooling and typed client pipelines

## What is the problem?
NET Core's Default HttpClientFactory implementation offers a ton of benefits in terms of managing HttpClient instances, including reuse and disposal of primary handlers and adding handler pipelines and policies using named or typed clients, as described at https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests

All instances of a named or typed client will use the same primary handler configuration, with the handler shared in the pool. For most per-request settings, this may not be an issue, but as the primary handler cannot be reconfigured per request and is not exposed once the HttpClient is returned, there is no way to customize certificates based on some contextual element of the request.

Suppose that we have a typed client called CommerceHttpClient with a well-defined set of calls and a robust delegating handler and retry pipeline. The service behind our typed client authenticates via certificates, and there are maybe 4 or 5 different certificates needed depending on the subdomain in the URL of a given request. Under the default HttpClientFactory implementation, you would need to register a different typed client and pipeline for each subdomain so that the primary handler delegate configures the certificate correctly, and moreso you would have to perform this registration for all known iterations of the sites at the composition root. **Yikes...**

A quick web search for "change certificate per request httpclientfactory" shows that this is not an uncommon problem, and most of the answers are less than ideal, summing up to "create your HttpClient manually," which means you lose the benefits of HttpClientFactory.

## What is this package?
By adding in a few additional classes and components that wrap the existing DefaultHttpClientFactory implementation, we can establish a pattern for requesting a typed client that has a primary handler properly scoped for a given context, assuming that you can translate that context into a string and map it to configuration for a primary handler. That could be part of your request URL, your logged in user, the current date, whatever. Best of all, we keep all the base functionality and benefits that the HttpClientFactory can offer!

![alt text](https://github.com/agertenbach/Ringleader/blob/master/workflow.PNG "Ringleader Workflow")

Under the hood, Ringleader directs the DefaultHttpClientFactory to create unique primary handlers in the pool specific to not only the typed client, but the passed context, as well. They will be managed and recycled just like any other handlers, and shoud not interfere with any handlers generated by other clients that are generated using the standard HttpClientFactory approach, including even the typed client you set up for Ringleader if you instantiate it that way. 

## How do I use it?
Ringleader is available from NuGet, or can be built from this source along with a sample project and XUnit tests. It includes a fluent builder for registering your classes to the ASP NET Core DI service container during startup.

### Implement some Ringleader interfaces
Ringleader requires that, in addition to your typed HttpClient, you implement two interfaces to support the contextual management of primary handlers: An **IHttpContextualClientFactory<TClient,TContext>**, and an **IPrimaryHandlerFactory**. The abstract class **HttpContextualClientFactory<TClient,TContext>** provides a baseline implementation for the first of the two pre-configured with injection of the Ringleader client/handler registry interface, the NET Core IHttpClientFactory, and a Microsoft.Extensions.Logging.ILogger, as well as additional abstract and virtual methods for registering and resolving identifiers, and is recommended for use unless you need to explicitly override its behavior.

The **TClient** parameter is your typed HttpClient, and the **TContext** parameter reflects an object that you pass at request time that can be translated to an appropriate string by your IHttpContextualClientFactory and will be later passed to the IPrimaryHandlerFactory responsible for returning an appropriate handler. 

For example, you could pass a POCO, an enum, or a Uri, and then define some logic that translates that object to a string representation as you see fit, combining values, extracting part of the host, checking query parameters, etc. The example above demonstrates this for a Uri and takes advantage of the abstract HttpContextualClientFactory class as a base, which reduces some boilerplate. 

```csharp
using System;
using System.Net.Http;
using Microsoft.Extensions.Logging;
using Ringleader;

namespace RingleaderExample
{
    public class MyHttpClientFactory : HttpContextualClientFactory<MyHttpClient, Uri>
    {
        public MyHttpClientFactory(IHttpClientHandlerRegistry httpClientHandlerRegistry, IHttpClientFactory httpClientFactory, ILogger<MyHttpClientFactory> logger)
            : base(httpClientHandlerRegistry, httpClientFactory, logger)
        {
        }

        public override MyHttpClient GetTypedClientByContext(Uri context)
        {
            var httpClient = CreateClient(context);
            return new MyHttpClient(httpClient);
        }

        protected override string ResolveIdentifierByContext(Uri context)
        {
            return context.Host;    // Translate a Uri context to a string by getting the Host component
        }
    }
}
```

With the host being passed through as the context string, our IPrimaryHandlerFactory might look something like this, using a certificate provider that knows how to return the right certificate based on the hostname:

```csharp
using System;
using System.Net.Http;
using System.Security.Cryptography.X509Certificates;
using Ringleader;

namespace RingleaderExample
{
    public class MyPrimaryHandlerFactory : IPrimaryHandlerFactory
    {
        private readonly MyCertificateProvider _myCertificateProvider;

        public MyPrimaryHandlerFactory(MyCertificateProvider myCertificateProvider)
        {
            _myCertificateProvider = myCertificateProvider ?? throw new ArgumentNullException(nameof(myCertificateProvider));
        }
        public HttpMessageHandler CreateHandler(string name)
        {
            SocketsHttpHandler socketsHttpHandler = new SocketsHttpHandler();
            if (_myCertificateProvider.HasCertificate(name))
            {
                socketsHttpHandler.SslOptions = new System.Net.Security.SslClientAuthenticationOptions();
                socketsHttpHandler.SslOptions.ClientCertificates = new X509Certificate2Collection(_myCertificateProvider.GetCertificate(name));
            }

            return socketsHttpHandler;
        }
    }
}
```

### Register Ringleader at startup alongside your typed HttpClient

With your implemented Ringleader interfaces and typed client ready, you can register Ringleader using the fluent builder during your composition root (inside the ConfigureServices block of Startup for an ASP NET Core web project):

```csharp
// Add Ringleader with our contextual factory and handler factory
services.AddRingleader()
    .WithContextualClientFactory<MyHttpClientFactory, MyHttpClient, Uri>()
    .WithPrimaryHandlerFactory<MyPrimaryHandlerFactory>()
    .Build();

// Add our typed HttpClient and add a handler pipeline using the default syntax
services.AddTransient<ExampleDelegatingHandler>();
services.AddHttpClient<MyHttpClient>()
    .AddHttpMessageHandler<ExampleDelegatingHandler>();
```

### Start using your contextual factory

Pass your IHttpContextualClientFactory implementation into classes or controllers via dependency injection. Typed clients generated by the factory will have the delegating handler pipeline and policies in place as if they were fetched normally.

```csharp
public class ExampleController : ControllerBase
    {
        private readonly IHttpContextualClientFactory<MyHttpClient, Uri> _clientFactory;

        public ExampleController(IHttpContextualClientFactory<MyHttpClient, Uri> clientFactory)
        {
            _clientFactory = clientFactory;
        }

        public void MakeHttpCall(Uri uri)
        {
            _clientFactory.GetTypedClientByContext(uri).MyTypedMethod();
            ...
        }
    }
```
# Questions / FAQ / Notes

#### Do I really need Ringleader?
If you've got a typed HttpClient with a reasonably complex delegating handler or policy pipeline that is common across multiple endpoints that require unique versions of a primary handler (i.e. different certificates), then this is probably a good fit. Just keep in mind that the handler management in HttpClientFactory is predicated on the idea that those handlers will be reused; if you are making only one or two calls for a given context, calls are infrequent, or you have dozens or hundreds of contexts, do not expect to see much of the benefit of HttpClientFactory coming through!

#### What if I need more than one IHttpContextualClientFactory registered with Ringleader?
If you have multiple instances of IHttpContextualClientFactory, you can simply add additional calls to WithContextualClientFactory<T> in the fluent builder. All factories will share a common IPrimaryHandlerFactory for resolving the primary handler, so ensure that your context string contains something to differentiate them if there are risks of collision. If there is a need for a more advanced pattern, I can revisit a more thorough solution in a future release.

#### Does this break HttpClientFactory usage outside of Ringleader?
From my testing so far, no. If you notice any issues with more complex pipelines than I've tested, let me know by opening an issue. Everything in the library is open source and can be customized if needed.

#### The default HttpClientHandlerRegistry doesn't behave the way I need
By default, Ringleader registers a singleton class that stores handler/client relationships in memory using a HashSet, and delimits the names of the handler and client with an asterisk. If this behavior causes issues, you can implement IHttpClientHandlerRegistry yourself and register it in the fluent builder using WithCustomHandlerRegistry<T>()

#### I need my implementation of one of Ringleaders interfaces to be registered with a different service lifetime
By default, Ringleader registers the factories as transient and other services as singletons. If this doesn't work, services registered in the fluent builder have an optional second parameter to specify the service lifetime. You may also skip the fluent builder and register the services manually.

